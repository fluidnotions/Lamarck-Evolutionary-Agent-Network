"""
State management for HVAS Mini.

Defines the shared state structure used by LangGraph and all agents.
"""

from typing import TypedDict, Dict, List, Optional
from pydantic import BaseModel, Field
from datetime import datetime


class AgentMemory(BaseModel):
    """Individual agent memory record.

    Stored in ChromaDB and retrieved for context during generation.
    """

    content: str = Field(..., description="The generated content to remember")
    topic: str = Field(..., description="Topic this content relates to")
    score: float = Field(..., ge=0.0, le=10.0, description="Quality score (0-10)")
    timestamp: str = Field(
        default_factory=lambda: datetime.now().isoformat(),
        description="ISO timestamp of creation",
    )
    embeddings: Optional[List[float]] = Field(
        default=None, description="Vector embeddings for similarity search"
    )
    retrieval_count: int = Field(
        default=0, description="Number of times this memory has been retrieved"
    )

    class Config:
        """Pydantic configuration."""

        json_schema_extra = {
            "example": {
                "content": "Machine learning is a subset of artificial intelligence...",
                "topic": "machine learning basics",
                "score": 8.5,
                "timestamp": "2024-03-15T10:30:00",
                "retrieval_count": 3,
            }
        }


class BlogState(TypedDict):
    """Shared state for blog generation workflow.

    This state is passed between nodes in the LangGraph workflow.
    All agents read from and write to this shared state.
    """

    # Content generated by agents
    topic: str  # Input topic for blog post
    intro: str  # Introduction section
    body: str  # Main body section
    conclusion: str  # Conclusion section

    # Evaluation scores (0-10 scale)
    scores: Dict[str, float]  # {"intro": 8.5, "body": 7.0, "conclusion": 9.0}

    # Memory and evolution tracking
    retrieved_memories: Dict[
        str, List[str]
    ]  # Memories used by each agent
    parameter_updates: Dict[str, Dict[str, float]]  # Parameter changes per agent

    # Metadata
    generation_id: str  # Unique ID for this generation run
    timestamp: str  # ISO timestamp of generation start
    stream_logs: List[str]  # Activity logs for visualization


def create_initial_state(topic: str) -> BlogState:
    """Create initial state for a new blog generation.

    Args:
        topic: The topic to write about

    Returns:
        Initialized BlogState with empty values
    """
    import uuid

    return BlogState(
        topic=topic,
        intro="",
        body="",
        conclusion="",
        scores={},
        retrieved_memories={},
        parameter_updates={},
        generation_id=str(uuid.uuid4()),
        timestamp=datetime.now().isoformat(),
        stream_logs=[],
    )


def validate_state(state: BlogState) -> bool:
    """Validate that state has all required keys.

    Args:
        state: The state to validate

    Returns:
        True if valid, raises ValueError otherwise
    """
    required_keys = [
        "topic",
        "intro",
        "body",
        "conclusion",
        "scores",
        "retrieved_memories",
        "parameter_updates",
        "generation_id",
        "timestamp",
        "stream_logs",
    ]

    missing = [key for key in required_keys if key not in state]
    if missing:
        raise ValueError(f"State missing required keys: {missing}")

    return True
